#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Feb  1 12:23:13 2019
    derive from bd2_7layers_kir4_grad, 7 layer model
    %bd2_7layers_kir4_grad(D_coe, coe_iso, iso_core,core,core_iso, iso_coe, coe_D,...
    %                      ab_D_coe, ab_coe_iso,ab_iso_core, ab_core, ab_core_iso,...
    %                      ab_iso_coe,ab_coe_D, T0, Ti, lamda)
    %
    % Input list:
    % layer thickness (um) - D_coe, coe_iso, iso_core,core,core_iso, iso_coe,coe_D
    % absorption coefficient (m^-1) - ab_D_coe, ab_coe_iso,ab_iso_core,
    % ab_core, ab_core_iso, ab_iso_coe,ab_coe_D
    % T0 (K) - diamond/sample intereface temperature
    % Ti (K) - core temperature
    % lamda (m) - wavelength of light
    % Output list:
    % I (W/m^3) - intensity of light from D_coe side
    % Note
    % absorption coefficient is 0 when absorption is not considered
    % Temperature profile can be generated by uncomment figure(11), it is
    % always good T0 re-check it T0 see if T profile makes sense
    %
    % Ref. Deng et al., 2017
    % By Jie Deng, 03/30/2017
    
1- delete cal_I the old way of integration where E is treated as indepent 
   of temeprature when integrate from equation 2 of Deng et al., 2017
2- Now Cal_I is directly from equation 2
TODO
1 - automous inverse modeling
2 - better time complexity
@author: jiedeng
"""
import numpy as np
import matplotlib.pyplot as plt
from lmfit import Parameters, report_fit,Model
from scipy.interpolate import interp1d
from scipy.integrate import odeint
#import scipy.constants as con
################################################################################      
class tcdac:
    """ Python Class for temperature correction """
    def __init__(self,D, Ti, lamda, T0 = 300, step = 0.01e-6):
        self.D     = np.array(D)*1e-6
        self.Ti    = Ti
        self.T0    = T0
        self.step  = step
        self.lamda = lamda        
        ####################temeprature profile#########################
        self.z = None
        self.T = None
        self.I = None
        
    def l7_grad(self):
        """
        temperature profile
        """
        D_coe    = D1 = self.D[0];
        coe_iso  = D2 = self.D[1];
        iso_core = D3 = self.D[2];
        core     = D4 = self.D[3];
        core_iso = D5 = self.D[4];
        iso_coe  = D6 = self.D[5];
        coe_D    = D7 = self.D[6];    
        self.n7  = np.zeros(7).astype(int)
        
        # Absolute distance from diamond, spacing is 0.01 um
        z_D_coe    = np.arange(0,D1,self.step);  self.n7[0] = len(z_D_coe);   
        z_coe_iso  = np.arange(0,D2,self.step);  self.n7[1] = len(z_coe_iso);   
        z_iso_core = np.arange(0,D3,self.step);  self.n7[2] = len(z_iso_core); 
        z_core     = np.arange(0,D4,self.step);  self.n7[3] = len(z_core); 
        z_core_iso = np.arange(0,D5,self.step);  self.n7[4] = len(z_core_iso);
        z_iso_coe  = np.arange(0,D6,self.step);  self.n7[5] = len(z_iso_coe); 
        
        ##### z_coe_D is specially delta with because of np.arange does not count the last value##
        z_coe_D    = np.arange(0,D7,self.step);  
        z_coe_D    = np.concatenate((z_coe_D,[D7])); self.n7[6] = len(z_coe_D);  
        z_D_core = np.concatenate((z_D_coe,(D_coe + z_coe_iso),(D_coe+ coe_iso + z_iso_core))); # 0 is D
        z_core_D = np.concatenate((z_core_iso,(z_iso_coe+core_iso), (z_coe_D + iso_coe+core_iso))); # 0 is iso/coe boundary
        D_core   = D_coe+ coe_iso+iso_core; 
        core_D   = core_iso+iso_coe+coe_D;
        
        T_D_core = self.T0+2*(self.Ti-self.T0)/(D_core**2)*((z_D_core)*D_core - (z_D_core)**2/2);
        T_core_D = self.T0+2*(self.Ti-self.T0)/(core_D**2)*(core_D**2/2 - (z_core_D)**2/2);  
        T_core   = self.Ti*np.ones(self.n7[3]); 
#  
        z1 = z_D_coe
        z2 = D_coe + z_coe_iso
        z3 = D_coe + coe_iso + z_iso_core
        z4 = D_coe + coe_iso + iso_core + z_core
        z5 = D_coe + coe_iso + iso_core + core + z_core_iso
        z6 = D_coe + coe_iso + iso_core + core + core_iso + z_iso_coe 
        z7 = D_coe + coe_iso + iso_core + core + core_iso + iso_coe + z_coe_D
        
        self.zseg = [z1,z2,z3,z4,z5,z6,z7]
        self.zseg2 = [z_D_coe,z_coe_iso,z_iso_core,z_core,z_core_iso,z_iso_coe,z_coe_D]
        self.z = np.concatenate((z1,z2,z3,z4,z5,z6,z7))
        self.T = np.concatenate((T_D_core,T_core,T_core_D))

        
    def l7_ab(self,ab):
        """
        otpical profile
        """
        N    = len(self.lamda);
        M    = len(self.z)
        A1 = ab[:,0]
        A2 = ab[:,1]
        A3 = ab[:,2]
        A4 = ab[:,3]
        A5 = ab[:,4]
        A6 = ab[:,5]
        A7 = ab[:,6]
        self.zA   = np.ones((M,N))
        self.ztau = np.ones((M,N))

        for i in range(N):
            zab1 = np.ones(self.n7[0])*A1[i]
            zab2 = np.ones(self.n7[1])*A2[i]
            zab3 = np.ones(self.n7[2])*A3[i]
            zab4 = np.ones(self.n7[3])*A4[i]
            zab5 = np.ones(self.n7[4])*A5[i]
            zab6 = np.ones(self.n7[5])*A6[i]
            zab7 = np.ones(self.n7[6])*A7[i]
            self.zA[:,i]   = np.concatenate((zab1,zab2,zab3,zab4,zab5,zab6,zab7))
            
    def cal_tau(self):
        """
        calculate optical depth
        ref. Deng et al., 2017
        """
        N    = len(self.lamda);
        M    = len(self.z)            
        for i in range(N):
            for j in range(M):
                self.ztau[j,i] = np.trapz(self.zA[:(j+1),i],x = self.z[:(j+1)])
            
    def fit_planck(self):
        T_wien,em_wien = fit_wien(self.lamda,self.I)
        bmmodel        = Model(planck,independent_vars=['lamda'])
        params         = Parameters();
        params.add('T', value=T_wien); 
        params.add('em',value=em_wien)         
        self.result    = bmmodel.fit(self.I,params,lamda = self.lamda)
        # write error report
        report_fit(self.result)
        self.result.params.pretty_print()
        Ifit = bmmodel.eval(self.result.params,lamda = self.lamda)
        plt.figure()
        plt.plot(self.lamda*1e9, self.I,label = 'T gradient + absorption')
        plt.plot(self.lamda*1e9,Ifit,label = 'Fitted '+str(self.result.params.valuesdict()['T']) + ' K')
        plt.xlabel("wavelegnth (nm)")
        plt.ylabel("radiance (W/m^3)")
        plt.legend()
    
    def cal_I(self,side='positive'):
        """
        integrate radinace using Eq (2) 
        input list:  side -> side to integrate
        ref. Deng et al., 2017
        """
        ### initial condition
        I0 = 0
        ### 
        N        = len(self.lamda)
#        z = np.array([min(self.z),max(self.z)])
#        if len(self.z)<40
        #### the number of points does affect the integration results ####
        #### This may be realted to the implementation details of odeint ###
        #### 40 seems to be abundant, I am using 100 just in case, but it is slow!! ###
        z = np.linspace(min(self.z),max(self.z),80)
        self.I   = np.ones(N)
        for i in range(N):
            self.I[i] = odeint(self.model,I0,z,args=(self.lamda[i],side))[-1]
#        for i in range(1):
#            self.I = odeint(self.model,I0,self.z,args=(self.lamda[i],side))
#        for i in range(1):
#            self.I = odeint(self.model,I0,z,args=(self.lamda[i],side))
#        plt.figure()
#        plt.plot(z*1e6,self.I)

#        plt.figure()
#        plt.plot(self.lamda,self.I)
        

    def model(self,I,z,lamda,side):
        """
        """
        k = self.z2k(z,lamda,side)
        E = self.z2E(z,lamda,side)
#        print(z,k, E)
        dIdz = -k*I + k*E
        return dIdz
    
    def z2k(self,z,lamda,side):
        """
        function relates depth and absorption coefficient
        """
        lamda_index = int((lamda - self.lamda[0])/(self.lamda[1]-self.lamda[0]))        
        if side[0] == 'p' or side[0] == 'P':
            f = interp1d(self.z,np.flip(self.zA[:,lamda_index],0))
        else:
            f = interp1d(self.z,self.zA[:,lamda_index])
        if min(self.z) <= z <= max(self.z):
            out = f(z)
        else:
            out = 1     # should be 0, to avoid dive by zero error
        return out
        
    def z2E(self,z,lamda,side):
        """
        function relates depth and radiance
        """
        if side[0] == 'p' or side[0] == 'P':
            f = interp1d(self.z,np.flip(self.T,0))
        else:
            f = interp1d(self.z,self.T)
        if min(self.z) <= z <= max(self.z):
            T = f(z)
        else:
            T = 0
        out = planck(lamda,T)
        return out        

    def plotT(self):
        plt.figure()
        plt.plot(self.z*1e6,self.T)
        plt.xlabel('Distance from upper diamond/sample interface (um)')
        plt.ylabel('Temperature (K)')

        
    def plotab(self):
        plt.figure()
        plt.plot(self.z*1e6,self.zA[:,0]/100)   
        plt.xlabel("Distance from upper diamond/sample interface (um)'")
        plt.ylabel("absorption coefficient (cm^-1)")
#        plt.subplot(122) 
#        plt.plot(self.z*1e6,self.ztau[:,0])
#        plt.xlabel("Distance from upper diamond/sample interface (um)")
#        plt.ylabel("Integrated optical depth")
        
    def plotI(self):
        plt.figure()
        plt.plot(self.lamda*1e9, self.I,label = 'T gradient + absorption')
        lamda_in = np.linspace(300,1500,100)*1e-9
        plt.plot(lamda_in*1e9,planck(lamda_in,self.Ti),label = 'Background')
        plt.xlabel("wavelegnth (nm)")
        plt.ylabel("radiance (W/m^3)")
        plt.legend()

        
########## external functions    ##########        
c = 3*1e8;                          # speed of light in vaccum
h = 6.625*1e-34;                    # Planck constant 
k = 1.38*1e-23;                     # Boltzmann constant
def planck(lamda, T, em=1):
    """
    calculate thermal radiance using Planck function
    It is intentionally made as external to do the fitting
    """
    I_planck = em*2*np.pi*h*(c**2)/(lamda**5)*1/(np.exp(h*c/(lamda*k*T))-1)
    return I_planck

def fit_wien(lamda,I):
    
    Wien = k/h/c*np.log(2*np.pi*h*(c**2)/I/(lamda**5)); 
    p    = np.polyfit(1./lamda,Wien,1); 
    T    = 1/p[0];
    temp = np.poly1d(p)
    em   = np.exp(-temp(0)*h*c/k);
    return T, em    

    
# test code of the above class

#if __name__ == '__main__':
##    sg = 0.8; pvs = 0.84; sm = 0.56; mm = 11.12; ms = 0.68; spv = 0.52; gs = 1.12;
#    sg =  0.02; pvs =  0.02; sm = 0.02; mm = 0.02; ms = 10; spv = 0.02; gs = 0.02;
#
#    D = [sg,pvs,sm,mm,ms,spv,gs]
#    Ti = 4000
#    T0 = 4000
#    
#    lamda = np.linspace(518, 683, 100)*1e-9
#    inp = tcdac(D, Ti,lamda)
#    inp.l7_grad()
##    inp.plotT()
#    ab1 = np.linspace(2970, 2970, 100)*1e2
#    ab2 = np.linspace(1000, 1000, 100)*1e2
#    ab = np.zeros((len(lamda),7))
#    ab[:,0] = ab1
#    ab[:,1] = ab2
#    ab[:,2] = ab2
#    ab[:,3] = ab2
#    ab[:,4] = ab2
#    ab[:,5] = ab2
#    ab[:,6] = ab1
#    inp.l7_ab(ab)
#    inp.plotab()
##    inp.cal_I()
##    inp.plotI()
##    inp.fit_planck()
#    inp.cal_I2()
#    plt.figure()
#    plt.plot(inp.z*16,inp.I2)